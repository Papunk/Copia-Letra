#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

	org	0x1C00
; LCD numbers   0     1     2     3     4     5     6     7     8     9     0crss 1cntr 4clsd 7diag
byteH   db      0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0xFC, 0x00, 0x61, 0x83
byteL   db      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x50, 0x20, 0x28
; Rndm letters	P	   F	      J	         G
randH	db	11001111b, 10001111b, 01111000b, 10111101b
randL	db	00000000b, 00000000b, 00000000b, 00000000b
; ISRs
	org	0xFFDA                  ; vector for PORT1
	dc16	portOneISR
        
        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


main:
        mov #0,R5
        mov #0,R6
        mov #0,R7
        
        ;call #SetupP1
        ;call #UnlockGPIO
	call	#setupApp
	call	#displayTitle
        call    #setupTimer
mainloop:
	; If state is 1 (game), go to game. Else keep displaying the title.
	cmp	#1,R15
	jz	game
        
	jmp	mainloop
        
TIMER_A0_ISR:

        ;xor.b #BIT7, P9OUT              ; just to toggle green LED each time the
                                        ; ISR is executed
        ;cmp #9, intsCounter             ; To toggle red LED each time the 
                                        ; interrupt counter reaches 10
        ;jnz noToggle
        ;xor.b #BIT0, P1OUT              ; Toggle red LED
                                        ; CCIFG automatically reset when entering
              	                        ; the ISR so no need to clear the flag
        ;mov #0, intsCounter
        ;CMP #0,R15
        ;JNZ notZero
        INC R5        
        reti
        
game:
        mov.w	#2,&LCDCMEMCTL //Clear LCD
        call    #showRandomLetter
	call	#setupGame
	;call	#clearDisplay	// just for testing
gameLoop:
// game subroutine calls go here
	call	#displayGameState
	; If state is 2 (game ended), go to the end loop. Else keep stay in the game loop.
	cmp	#2,R15
	jz	endLoop
	jmp	gameLoop


endLoop:
// keep displaying the end state + the led depending on game result
	; If state is 1 (game), go to game. Else keep stay in the end loop.
	cmp	#1,R15
	jz	game
	jmp	endLoop



; ---------------------------------------------------------------------------------------
; Gameloop Subroutines
; ---------------------------------------------------------------------------------------

// TODO: set up initial values
setupGame:
        mov #0,R5
	ret

// TODO: display the randomly chosen letter, the current state of the attempt, and the current time
displayGameState:
        call #cronometer
	ret

cronometer:
        CMP #10,R5
        JNZ lessThan10
        mov #0, R5
        INC R6
        CMP #6,R6
        JNZ lessThan10
        mov #0, R6
        INC R7        
lessThan10:
        mov.b byteH(R7), &0xA32
        mov.b byteL(R7), &0xA33
        bis.b #100b,&0xA33
        mov.b byteH(R6), &0xA2E
        mov.b byteL(R6), &0xA2F
        mov.b byteH(R5), &0xA27
        mov.b byteL(R5), &0xA28
        ret

; ---------------------------------------------------------------------------------------
; Endloop Subroutines
; ---------------------------------------------------------------------------------------


; ---------------------------------------------------------------------------------------
; Mainloop Subroutines
; ---------------------------------------------------------------------------------------

displayTitle:
	; C
	mov.b	#10011100b,&0xA29
	mov.b	#00000000b,&0xA2A
	; P
	mov.b	#11001111b,&0xA25
	mov.b	#00000000b,&0xA26
	; L
	mov.b	#00011100b,&0xA23
	mov.b	#00000000b,&0xA24
	; E
	mov.b	#10011110b,&0xA32
	mov.b	#00000000b,&0xA33
	; T
	mov.b	#10000000b,&0xA2E
	mov.b	#01010000b,&0xA2F
	; R
	mov.b	#11001111b,&0xA27
	mov.b	#00000010b,&0xA28
	ret

// TODO split into 3 subroutines for cleanliness (General setup, LCD setup, Button setup)
setupApp:
; Stop watchdog timer
        mov.w   #WDTPW+WDTHOLD,&WDTCTL
; Setup state
	mov.w	#0,R15
; Setup buttons
	; Set PxSel0 and PxSel1 as digital I/O
	bic.b   #0xFF,&P1SEL0
        bic.b   #0xFF,&P1SEL1
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        

	; Set P1.1 and P1.2 for input and the rest to output
	mov.b   #11111001B,&P1DIR
	; Set all P9 pins for output
	bis.b   #0xFF,&P9DIR
	; Activate P1.1 and P1.2 pullup resistors
        bis.b   #00000110b,&P1REN
	bis.b   #00000110b,&P1OUT
	; Enable P1.1 and P1.2 interrupts
	bis.b	#00000110b,&P1IE
	; Set interrupt on high to low transitions
	bis.b	#00000110b,&P1IES
; Setup LCD
	; Enable segments
	mov.w	#0xFFFF,&LCDCPCTL0
	mov.w	#0xFC3F,&LCDCPCTL1
	mov.w	#0xFFFF,&LCDCPCTL2
	; Unlock GPIO
        bic.w	#LOCKLPM5,&PM5CTL0
	; Initialize LCD
        mov.w	#0x041e,&LCDCCTL0
	; Enable charge pump
        mov.w	#0x0208,&LCDCVCTL
	; Clock sync
        mov.w	#0x8000,&LCDCCPCTL
	; Clear LCD memory
        mov.w	#2,&LCDCMEMCTL
	; Turn LCD on
        bis.w	#1,&LCDCCTL0

; Turn off LEDS
	bic.b	#00000001b,&P1OUT
	bic.b	#10000000b,&P9OUT
; Prevent previous button presses
	bic.b	#00000110b,&P1IFG
; Enable interrupts
	nop
	bis.w	#GIE,SR
	nop
        ret
        
setupTimer:       
        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000010b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
        nop				; required befor enabling interrupts

        ;bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        bis     #GIE, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts
        ;nop                             ; Required after enabling interrupts      
	ret

; ---------------------------------------------------------------------------------------
; Input Handlers
; ---------------------------------------------------------------------------------------

portOneISR:
	;call	#delay
	bit.b	#00000010b,&P1IFG
	jnz	interruptAtS1
	bit.b	#00000100b,&P1IFG
	jnz	interruptAtS2
handledISR:
	reti
interruptAtS1:
	bic.b	#00000010b,&P1IFG
	call	#handleS1
	jmp	handledISR
interruptAtS2:
	bic.b	#00000100b,&P1IFG
	call	#handleS2
	jmp	handledISR


// Set to clearDisplay for testing purposes

handleS1:
	ret


handleS2:
	mov.w	#1,R15
        	nop				; required befor enabling interrupts

        ;bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        bis     #GIE, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts
endS2:
	ret


; ---------------------------------------------------------------------------------------
; Helper Subroutines
; ---------------------------------------------------------------------------------------

// Just for testing purposes, can probably delete later
clearDisplay:
	mov.b	#00000000b,&0xA29
	mov.b	#00000000b,&0xA2A

	mov.b	#00000000b,&0xA25
	mov.b	#00000000b,&0xA26

	mov.b	#00000000b,&0xA23
	mov.b	#00000000b,&0xA24

	mov.b	#00000000b,&0xA32
	mov.b	#00000000b,&0xA33

	mov.b	#00000000b,&0xA2E
	mov.b	#00000000b,&0xA2F

	mov.b	#00000000b,&0xA27
	mov.b	#00000000b,&0xA28
	ret

delay:
	push.w	R4
        mov.w 	#50000,R4
decrementDelay:
	dec 	R4
        jnz 	decrementDelay
	pop	R4
        ret


showRandomLetter:
        CMP #4,R5
        JLO lessThan4
        AND #3, R5 
lessThan4:
        mov.b	randH(R5),&0xA29
	ret




	END